---
title: 'Linear Regression: Release Date'
author: "Mary Solomon"
date: "2/15/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(lubridate) #for working with time stamps :D
library(tidyverse)
library(ggplot2)
library(ggthemes)
library(stringr)
library(scales) #for formatting with percentage signs
library(nnet) #for multinomial regression
library(caret)
library(car) #for vif function and boxcox transformation
library(MASS) #boxcox transformation
```


Load the functions
```{r}
source("thesis_functions.R")
dhist.plot <- function(d, v, vname){
  ggplot(d, aes(x=v)) + 
  geom_histogram(aes(y = stat(density)), bins = 30, fill = "white", col = "black") +
  stat_function(
    fun = dnorm, 
    args = list(mean = mean(d$v), sd = sd(d$v)), 
    lwd = 1, 
    col = 'red'
  ) +
  # xlab(vname) + ylab("Density") +
  # ggtitle(paste(vname, "Distribution")) +
  theme_bw()
}
```


set levels of ordinal data, and other variables to their appropriate dataypes. Did not adjust the datatypes for date/time since those will not be used in this portion
```{r}
data <- fread("kpopdata.csv")
data <- mutate(data, ArtistType = as.factor(ArtistType),
               ArtistGender = as.factor(ArtistGender),
               ArtistGen = factor(ArtistGen),
               release_date = as.POSIXct(release_date, format = "%m/%d/%y"),
               key = factor(key, levels = 0:11),
               mode = as.factor(mode),
               time_signature = factor(time_signature, levels = c(1,3,4,5)))

#make month/year as continuous data in the form of number of months (~360)
ref.year = 1992 #we are using January 1992 as the reference
data$months = 12*(year(data$release_date) - ref.year) + month(data$release_date)
#View(select(data, Artist, song_name, release_date, months))
```

# Assessing normality of the Response Variable: Month of release date.

check out distribution of the months 
```{r}
#dhist.plot(data, months, "Month Released")
ggplot(data, aes(x=months)) +
  geom_histogram(aes(y = stat(density)), bins = 30, fill = "white", col = "black") +
  stat_function(
    fun = dnorm, 
    args = list(mean = mean(data$months), sd = sd(data$months)), 
    lwd = 1, 
    col = 'red'
  ) +
  xlab("Month Released") + ylab("Density") +
  ggtitle(paste("Month Released", "Distribution")) +
  theme_bw()
summary(data$months)
```

try to find a transformation to normalize. As we can see the distribution of months is severely skewed to the left. 

A common distribution towards normality for moderately skewed data is : $log((max(y)+1) - y)$, since the max number of months is 349, the transformation would be : $log(350 - y)$
```{r}
ggplot(data, aes(x=log(350-data$months))) +
  geom_histogram(aes(y = stat(density)), bins = 30, fill = "white", col = "black") +
  stat_function(
    fun = dnorm, 
    args = list(mean = mean(log(350-data$months)), sd = sd(log(350-data$months))), 
    lwd = 1, 
    col = 'red'
  ) +
  xlab("Month Released : log(350 - y))") + ylab("Density") +
  ggtitle(paste("Month Released : log(350 - y))", "Distribution")) +
  theme_bw()
summary(data$months)
```

Another common transformation for moderate skewed data is a square root approach: $\sqrt{((max(y)+1) - y)}$ = $\sqrt{(350 - y)}$
```{r}
ggplot(data, aes(x=sqrt(350-data$months))) +
  geom_histogram(aes(y = stat(density)), bins = 30, fill = "white", col = "black") +
  stat_function(
    fun = dnorm, 
    args = list(mean = mean(sqrt(350-data$months)), sd = sd(sqrt(350-data$months))), 
    lwd = 1, 
    col = 'red'
  ) +
  xlab("Month Released : sqrt(350 - y))") + ylab("Density") +
  ggtitle(paste("Month Released : sqrt(350 - y))", "Distribution")) +
  theme_bw()
summary(data$months)
```

Lastly, a common transformation for severely negatively skewed data takes an inverse approach: $\frac{1}{(max(y)+1) - y)}$ = $\frac{1}{(350 - y)}$
```{r}
ggplot(data, aes(x=1/(350-data$months))) +
  geom_histogram(aes(y = stat(density)), bins = 30, fill = "white", col = "black") +
  stat_function(
    fun = dnorm, 
    args = list(mean = mean(1/(350-data$months)), sd = sd(1/(350-data$months))), 
    lwd = 1, 
    col = 'red'
  ) +
  xlab("Month Released : 1/(350 - y))") + ylab("Density") +
  ggtitle(paste("Month Released : 1/(350 - y))", "Distribution")) +
  theme_bw()
summary(data$months)
```




# splitting into training and test data.
Create Training (75%) and Test data (25%) to train classification models on.
```{r}
kpop <- dplyr::select(data, months, popularity, duration, acousticness, danceability, energy, instrumentalness, key, loudness, mode, speechiness, tempo, valence)
kpop0 <- kpop %>% dplyr::filter(mode == 0) %>% dplyr::select(-mode)
kpop1 <- kpop %>% dplyr::filter(mode == 1) %>% dplyr::select(-mode)

### Kpop mode 0 train and test
smpl.size0 <- floor(0.75*nrow(kpop0))
set.seed(123)
smpl0 <- sample(nrow(kpop0), smpl.size0, replace = FALSE)
train0 <- kpop0[smpl0,]
test0 <- kpop0[-smpl0,]

### Kpop mode 1 train and test
smpl.size1 <- floor(0.75*nrow(kpop1))
set.seed(123)
smpl1 <- sample(nrow(kpop1), smpl.size1, replace = FALSE)
train1 <- kpop1[smpl1,]
test1 <- kpop1[-smpl1,]
```



### Multiple linear regression for mode 0 songs
```{r}
ml0 <- lm(months ~. , data = train0)
summary(ml0)
```

check assumptions with diagnostic plots
```{r}
#par(mfrow = c(4,1))
plot(ml0)
```

 * Residuals vs. Fitted : Does not show a horizontal line. There is a noticeable pattern of a slight curve in the trend. 
 
 * Normal QQ: Residual points roughly follow the normal QQ line. The left side falls below the normal line below theoretical quantile -2. Otherwise, the distribution of the residuals appears to roughly follow a normal distribution.   
 
 *Scale-Location: Due to the clear decreasing line rather thana flat horizontal line of equally spread points, there is clear evidence of violation for homogeneity of the variance of the residuals. May need to run the model on a transformation of the outcome variable which is the months of song release.
 
 * Residuals vs Leverage: There are some points that exceed -3 and 3 standard deviations, so we sould remove such points.
 



```{r}
qqnorm(ml0$residuals)
qqline(ml0$residuals, col = "red")
```

checking for multicollinearity
```{r}
car::vif(ml0)
```


Overall, the current model does not meet the assumptions of the linear model. We need to make a transformation on the response variable to achieve normality of the residuals

```{r}
yhat.ml0 = predict(ml0, newdata = test0)
data.frame(
  RMSE = RMSE(yhat.ml0, test0$months),
  R2 = R2(yhat.ml0, test0$months)
)
```



### MLR: Box Cox Transformation
```{r}
boxcox(ml0,lambda = seq(1.7, 3, 0.1), plotit = TRUE)
```

Optimal transformation is for $\lambda = 2.3$

```{r}
hist(bc.transform(data$months, 2.3))
```




```{r}
ml0.bc <- lm(bc.transform(months, 2.3) ~. , data = train0)
summary(ml0.bc)
```

check diagnostic plots
```{r}
plot(ml0.bc)
```

normality has improved but nothing else ...

```{r}
yhat.ml0.bc = predict(ml0.bc, newdata = test0 %>% mutate(months = bc.transform(test0$months, 2.3)))
data.frame(
  RMSE = RMSE(yhat.ml0.bc, bc.transform(test0$months, 2.3)),
  R2 = R2(yhat.ml0.bc, bc.transform(test0$months, 2.3))
)
```


### MLR: log(360 - y) Transformation
```{r}
hist(log(360-train0$months))
summary(log(360-train0$months))
```


```{r}
ml0.log360 <- lm(log(360-train0$months) ~. , data = train0)
summary(ml0.log360)
```


check diagnostic plots
```{r}
plot(ml0.log360)
```

Predictions and performance diagnostics
```{r}
yhat.ml0.log360 = predict(ml0.log360, newdata = test0 %>% mutate(months = log(360 - test0$months)))
data.frame(
  RMSE = RMSE(yhat.ml0.log360, log(360 - test0$months)),
  R2 = R2(yhat.ml0.log360, log(360 - test0$months))
)
```



### MLR: sqrt(350 - y) Transformation
```{r}
hist(sqrt(350-train0$months))
summary(sqrt(350-train0$months))
```


```{r}
ml0.sqrt350 <- lm(sqrt(350-train0$months) ~. , data = train0)
summary(ml0.sqrt350)
```


check diagnostic plots
```{r}
plot(ml0.sqrt350)
```

Predictions and performance diagnostics
```{r}
yhat.ml0.sqrt350 = predict(ml0.sqrt350, newdata = test0 %>% dplyr::mutate(months = sqrt(350-test0$months)))
data.frame(
  RMSE = RMSE(yhat.ml0.sqrt350, sqrt(350-test0$months)),
  R2 = R2(yhat.ml0.sqrt350, sqrt(350-test0$months))
)
```

## Multiple linear regression for mode 1 songs


